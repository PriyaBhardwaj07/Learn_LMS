from django.shortcuts import get_object_or_404, render
from rest_framework import status
from django.contrib import messages
from django.db import transaction
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import generics
from core.custom_mixins import (
    ClientAdminMixin,
    ClientMixin,
    SuperAdminMixin)
from rest_framework.exceptions import NotFound, ValidationError
from django.core.exceptions import ObjectDoesNotExist
from django.core.exceptions import PermissionDenied
from django.shortcuts import get_object_or_404, render, redirect
from django.utils.decorators import method_decorator
from django.utils import timezone
from django.db.models import Q
from django.shortcuts import get_object_or_404, render
from rest_framework import status
from django.contrib import messages
from django.db import transaction
from backend.models.allmodels import (
    Course,
    CourseRegisterRecord,
    UploadVideo,
    UploadReadingMaterial,
    CourseStructure,
    CourseEnrollment,
    Quiz,
    Question,
)
from django.core.exceptions import PermissionDenied
from django.shortcuts import get_object_or_404, render, redirect
from django.utils.decorators import method_decorator
from backend.serializers.createcourseserializers import (
    ActivateCourseSerializer,
    CourseSerializer, 
    CourseStructureSerializer,
    CreateChoiceSerializer,
    InActivateCourseSerializer, 
    QuizSerializer, 
    CreateCourseSerializer,
    CreateUploadReadingMaterialSerializer,
)
import pandas as pd
###
from django.shortcuts import get_object_or_404, render
from rest_framework import status
from django.contrib import messages
from django.db import transaction
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from backend.forms import (
    QuestionForm,
)
from rest_framework.exceptions import NotFound, ValidationError
from django.core.exceptions import ObjectDoesNotExist
from django.core.exceptions import PermissionDenied
from django.shortcuts import get_object_or_404, render, redirect
from django.utils.decorators import method_decorator

from backend.models.coremodels import *
from backend.serializers.courseserializers import *


filtered_display = ["active", "inactive", "all"]
class CourseView(SuperAdminMixin, ClientAdminMixin, ClientMixin, APIView): #(SuperAdminMixin, ClientAdminMixin, ClientMixin)
    
    """
    post : create version 1 course
        while creating instance :
                    # slug = auto generated by pre_save()
                    title = request body
                    summary = request body
                    created_at = updated_at = models.DateTimeField(auto_now=True)
                    active = False
                    original_course = null (as it is original course itself)
                    version_number = 1
    get : 
            if course_id : single instance details are shown (for all users)
                what will be displayed of selected course:
                    id
                    title,
                    summary,
                    updated_at,
                    original_course [title to be extracted on frontend],
                    version_number
            if filtered_display : 
                what will be displayed:
                    id
                    slug
                    title
                    created_at
                    updated_at
                    active
                    original_course 
                    version_number
                all -> list of all courses (super admin allowed only)
                active -> list of active courses (for all users)
                inactive -> list of inactive courses (super admin allowed only)
    """ 
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, *args, **kwargs):
        try:
            course_id = request.query_params.get('course_id')
            filtered_display = request.query_params.get('filtered_display')

            if not course_id or not filtered_display:
                return Response({"error": "Course ID is missing from query parameters."}, status=status.HTTP_400_BAD_REQUEST)

            if course_id:
                course = Course.objects.get(pk=course_id)
                if not course:
                    return Response({"error": "No course found with the provided ID."}, status=status.HTTP_404_NOT_FOUND)
                if course.deleted_at:
                    return Response({"error": "Access to deleted course is not allowed."}, status=status.HTTP_403_FORBIDDEN)
                serializer = CourseSerializer(course)
                return Response(serializer.data, status=status.HTTP_200_OK)

            if filtered_display:
                if filtered_display not in ["active", "inactive", "all"]:
                    return Response({"error": "Invalid filtered_display parameter"}, status=status.HTTP_400_BAD_REQUEST)
                
                queryset = Course.objects.filter(deleted_at__isnull=True).order_by('-created_at')
                
                if filtered_display == "active":
                    queryset = queryset.filter(active=True)
                elif filtered_display == "inactive":
                    if not self.has_super_admin_privileges(request):
                        return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                    
                    queryset = queryset.filter(active=False)
                elif filtered_display == "all":
                    if not self.has_super_admin_privileges(request):
                        return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                    
                course_list = queryset.all()
                
                if not course_list.exists():
                    return Response({"message": "No course found.", "data": []}, status=status.HTTP_404_NOT_FOUND)
                serializer = CourseDisplaySerializer(course_list, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, *args, **kwargs):        
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            data = request.data
            if not data:
                return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)
            serializer = CreateCourseSerializer(data=data)
            if serializer.is_valid():
                serializer.validated_data['active'] = False
                serializer.validated_data['original_course'] = None
                serializer.validated_data['version_number'] = 1
                course = serializer.save()
                return Response({"message": "Course created successfully", "course_id": course.pk}, status=status.HTTP_201_CREATED)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


manage_status = ["activate", "inactivate","versioning"]
class ManageCourseView(SuperAdminMixin, APIView):
    """
        only accessible to super admin
        manage_status : 
            activate:
                if original_course field is null for this course_id 's instance:
                updating instance field:
                            change active from False to True
                if not null :
                        compare course structure for set of  (content_type , content_id) of course_id in url and id of course which is mentioned in original_course.
                        if match :
                                can't activate the course
                        if not match:
                                activate the course by changing active from False to True
            inactivate:
                do it by giving warning by counting the number of instances in course enrollment table where course_id is same as that in url and active is True. [to tell how many people are studying the course now]
                
                doing this : inactivating a course , it should be appearing for employees to study it or even register it any furthur customer,
                but the history of users regarding this course should not be erased.
                
                updating instance field:
                            change active from True to False
            versioning:
                on saving , new instance of course will be created :
                            slug = auto generated
                            title = same as course in url for now
                            summary = same as course in url for now
                            created_at = updated_at = now()
                            active = False
                            original_course = course id in url
                            version_number = count the instances for which course_id in url is originalcourse, and add 2 to that count, and pass it as version_number
                in course_structure table , taking the course_id from url, and id of newly created instance:
                        copy what is related to id in url to new instance.
                similarly for all reading material, video , quiz which are in relation with course_id in url , will be mapped with new instance too
    """
    def post(self, request, *args, **kwargs):
        try:
            if not self.has_super_admin_privileges(request):
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            manage_status = request.data.get('manage_status')
            
            if manage_status not in ["activate", "inactivate","versioning"]:
                return Response({"error": "Invalid manage_status in request"}, status=status.HTTP_400_BAD_REQUEST)
            course_id = request.data.get('course_id')
            if not course_id:
                return Response({"error": "Course ID is missing"}, status=status.HTTP_400_BAD_REQUEST)
            if manage_status == "activate":
                return self.activate_course(course_id)
            elif manage_status == "inactivate":
                return self.inactivate_course(course_id)
            elif manage_status == "versioning":
                return self.create_course_derived_version(course_id)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def activate_course(self, course_id):
        try:
            course = Course.objects.get(pk=course_id, deleted_at__isnull=True)
            if not course:
                return Response({"error":"no course found"},status=status.HTTP_404_NOT_FOUND)
            serializer = ActivateCourseSerializer(data={'course_id': course.id})
            if serializer.is_valid():
                course = serializer.validated_data['course_id']
                if course.original_course is None:
                    course.active = True
                    course.save()
                    return Response({"message": "Course activated successfully."}, status=status.HTTP_200_OK)
                else:
                    original_course_structure = CourseStructure.objects.filter(course=course.original_course).values_list('content_type', 'content_id')
                    current_course_structure = CourseStructure.objects.filter(course=course).values_list('content_type', 'content_id')
                    if not original_course_structure or not current_course_structure:
                        return Response({"message":"Course Structure not found."}, status=status.HTTP_404_NOT_FOUND)

                    original_course_structure_df = pd.DataFrame(original_course_structure, columns=['content_type', 'content_id'])
                    current_course_structure_df = pd.DataFrame(current_course_structure, columns=['content_type', 'content_id'])

                    if original_course_structure_df.equals(current_course_structure_df):
                        return Response({"error": "Cannot activate the course. Course structure have exact match with original course."},
                                        status=status.HTTP_400_BAD_REQUEST)
                    else:
                        course.active = True
                        course.save()
                        return Response({"message": "Course activated successfully."}, status=status.HTTP_200_OK)
            else:
                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    def inactivate_course(self, course_id):
        try:
            serializer = InActivateCourseSerializer(data={'course_id': course_id})
            if serializer.is_valid():
                course = serializer.validated_data['course_id']
                active_enrollments_count = CourseEnrollment.objects.filter(course=course, active=True, deleted_at__isnull=True).count()
                if not active_enrollments_count:
                    return Response({"error":"no active course enrollment found"},status=status.HTTP_404_NOT_FOUND)
                course.active = False
                course.save()
                return Response({"message": "Course inactivated successfully.",
                                "active_enrollments_before_inactivation": active_enrollments_count},
                                status=status.HTTP_200_OK)
            else:
                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
                
    def create_course_derived_version(self, course_id):
        try:
            original_course = Course.objects.get(pk=course_id)
            if not original_course.active:
                return Response({"error": "The original course is not active"}, status=status.HTTP_400_BAD_REQUEST)
            inactive_versions_count = Course.objects.filter(Q(original_course=original_course) & Q(active=False, deleted_at__isnull=True)).count()
            if inactive_versions_count >= 2:
                return Response(
                    {"error": "Two or more inactive versions of this course already exist. Delete or activate them first."},
                    status=status.HTTP_400_BAD_REQUEST)
        except Course.DoesNotExist:
            return Response({"error": "Original course not found."}, status=status.HTTP_404_NOT_FOUND)
        try:
            with transaction.atomic():
                # Create new course instance based on original course
                new_course_data = {
                    'title': original_course.title,
                    'summary': original_course.summary,
                    'active': False,
                    'original_course': original_course.id,
                    'created_at': timezone.now(),
                    'updated_at': timezone.now(),
                    'version_number': Course.objects.filter(original_course=original_course).count() + 2
                }
                new_course_serializer = CourseSerializer(data=new_course_data)
                if new_course_serializer.is_valid():
                    new_course = new_course_serializer.save()
                else:
                    return Response({"error": new_course_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
                
                # Copy course structure from original course
                original_course_structure = CourseStructure.objects.filter(course=original_course)
                if not original_course_structure:
                    return Response({"error": "The original course structure not found"}, status=status.HTTP_404_NOT_FOUND)
                for structure in original_course_structure:
                    structure_data = CourseStructureSerializer(structure).data
                    structure_data['course'] = new_course.pk
                    structure_serializer = CourseStructureSerializer(data=structure_data)
                    if structure_serializer.is_valid():
                        structure_serializer.save()
                    else:
                        return Response({"error": structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
                
                related_reading_materials = UploadReadingMaterial.objects.filter(courses=original_course)
                if related_reading_materials:
                    new_course.reading_materials.set(related_reading_materials)
                    
                # Map existing UploadVideo
                related_videos = UploadVideo.objects.filter(courses=original_course)
                if related_videos:
                    new_course.video_materials.set(related_videos)
                    
                # Map existing Quiz
                related_quizzes = Quiz.objects.filter(courses=original_course)
                if related_quizzes:
                    new_course.quizzes.set(related_quizzes)
            return Response({"message": "New version of course created successfully."}, status=status.HTTP_201_CREATED)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class CourseStructureView(SuperAdminMixin, ClientAdminMixin, ClientMixin, APIView):
    """
        get: to retieve the course structure of course in url (for authorized all)
        post: to create course structure instances for course in url (for super admin only)
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, course_id, format=None):
        try:
            course_structures = CourseStructure.objects.filter(course_id=course_id, active=True, deleted_at__isnull=True)
            if course_structures.exists():
                serializer = CourseStructureSerializer(course_structures, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "No course structures found for the specified course ID"}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, course_id, *args, **kwargs):

        if not self.has_super_admin_privileges(request):
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        # Check if course exists
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        # Check if the course is active
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)
        try:
            # Extract data from request body
            order_numbers = request.data.get('order_number', [])
            content_types = request.data.get('content_type', [])
            content_ids = request.data.get('content_id', [])
            
            # Check if lengths of lists are same
            if len(order_numbers) != len(content_types) or len(content_types) != len(content_ids):
                return Response({"error": "Length of order_number, content_type, and content_id lists must be the same"}, status=status.HTTP_400_BAD_REQUEST)
            
            # Create CourseStructure instances
            new_created_course_structure = []
            course_structure_data = []
            existing_course_structure_data = []
            edited_existing_course_structure_data = []
            
            for order_number, content_type, content_id in zip(order_numbers, content_types, content_ids):
                # Check if an instance with similar course_id, content_type, content_id, and order_number exists
                instance_exists = CourseStructure.objects.filter(course=course_id, content_type=content_type, content_id=content_id, order_number=order_number).exists()
                if instance_exists:
                    data = {
                        'course': course_id,
                        'order_number': order_number,
                        'content_type': content_type,
                        'content_id': content_id
                    }
                    existing_course_structure_data.append(data)
                    course_structure_data.append(data)
                    # Skip mapping this instance
                    continue
                
                # Check if there's an existing instance with the same content_id and content_type but different order_number
                existing_instance = CourseStructure.objects.filter(course=course_id, content_type=content_type, content_id=content_id).first()
                if existing_instance:
                    # Update the order_number
                    existing_instance.order_number = order_number
                    existing_instance.save()
                    data = {
                        'course': course_id,
                        'order_number': order_number,
                        'content_type': content_type,
                        'content_id': content_id
                    }
                    edited_existing_course_structure_data.append(data)
                    course_structure_data.append(data)
                else:
                    # Create a new instance
                    data = {
                        'course': course_id,
                        'order_number': order_number,
                        'content_type': content_type,
                        'content_id': content_id
                    }
                    new_created_course_structure.append(data)
                    course_structure_data.append(data)
            
            # Save new instances
            serializer = CourseStructureSerializer(data=new_created_course_structure, many=True)
            if serializer.is_valid():
                serializer.save()
                return Response({"message": "Course structure created successfully", 
                                "existing_record": existing_course_structure_data,
                                "edited_records" : edited_existing_course_structure_data,
                                "new_records": new_created_course_structure,
                                "all_record": course_structure_data
                                }, status=status.HTTP_201_CREATED)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class ReadingMaterialView(SuperAdminMixin, ClientAdminMixin, ClientMixin, APIView):
    """
        get: to retieve the reading material of course in url (for authorized all)
        post: to create reading material instances for course in url (for super admin only)
    """
    
    def get(self, request, course_id, format=None):
        
        try:
            # user = request.user
                # =================================================================
            user_header = request.headers.get("user")
            if user_header:
                user = json.loads(user_header)
                customer_id = user.get("customer")
                # =================================================================
            actively_enrolled = CourseEnrollment.objects.filter(course=course_id, user=user.id, active=True).exists()
            actively_registered = CourseRegisterRecord.objects.filter(course=course_id, customer=user.customer.id, active=True).exists()
            
            if not self.has_super_admin_privileges(request) or not actively_enrolled or not actively_registered :
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            
            content_id = request.query_params.get('content_id')
            list_mode = request.query_params.get('list', '').lower() == 'true'  # Check if list mode is enabled
            if content_id:
                reading_material = UploadReadingMaterial.objects.get(
                    courses__id=course_id, 
                    id=content_id, 
                    active=True, 
                    deleted_at__isnull=True
                    )
                if reading_material :
                    serializer = ReadingMaterialSerializer(reading_material)
                    return Response(serializer.data, status=status.HTTP_200_OK)
            elif list_mode:
                reading_materials = UploadReadingMaterial.objects.filter(
                    courses__id=course_id, 
                    active=True, 
                    deleted_at__isnull=True
                )
                serializer = ReadingMaterialListPerCourseSerializer(reading_materials, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Specify 'content_id' or enable 'list' mode in query parameters."}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, course_id, *args, **kwargs):
        
        if not self.has_super_admin_privileges(request):
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)

        data = request.data
        if not data:
            return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            serializer = CreateUploadReadingMaterialSerializer(data=data)
            if serializer.is_valid():
                # Set additional fields
                serializer.validated_data['courses'] = [course_id]
                reading_material = serializer.save()
                # If original_course is null, only save reading material
                if course.original_course is None:
                    return Response({"message": "Reading material created successfully"}, status=status.HTTP_201_CREATED)
                else:
                    # If original_course is not null, also create a CourseStructure entry
                    try:
                        last_order_number = CourseStructure.objects.filter(course=course).latest('order_number').order_number
                    except CourseStructure.DoesNotExist:
                        last_order_number = 0
                    # Create new CourseStructure instance
                    course_structure_data = {
                        'course': course_id,
                        'order_number': last_order_number + 1,
                        'content_type': 'reading',
                        'content_id': reading_material.pk
                    }
                    course_structure_serializer = CourseStructureSerializer(data=course_structure_data)
                    if course_structure_serializer.is_valid():
                        course_structure_serializer.save()
                        return Response({"message": "Reading material created successfully"}, status=status.HTTP_201_CREATED)
                    else:
                        return Response({"error": course_structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class QuizView(SuperAdminMixin, ClientAdminMixin, ClientMixin,APIView):
    """
        get: to retieve the quiz of course in url (for authorized all)
        post: to create quiz instances for course in url (for super admin only)
    """
    def get(self, request, course_id,format=None):
        try:
            
            content_id = request.query_params.get('content_id')
            list_mode = request.query_params.get('list', '').lower() == 'true'  # Check if list mode is enabled
            if content_id:
                # user = request.user
                    # =================================================================
                user_header = request.headers.get("user")
                if user_header:
                    user = json.loads(user_header)
                    customer_id = user.get("customer")
                    # =================================================================
                actively_enrolled = CourseEnrollment.objects.filter(course=course_id, user=user.id, active=True).exists()
                actively_registered = CourseRegisterRecord.objects.filter(course=course_id, customer=user.customer.id, active=True).exists()
                if not self.has_super_admin_privileges(request) or not actively_enrolled or not actively_registered :
                    return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                quiz = Quiz.objects.get(
                    courses__id=course_id, 
                    id=content_id, 
                    active=True, 
                    deleted_at__isnull=True
                    )
                if quiz:
                    serializer = QuizSerializer(quiz)
                    return Response(serializer.data, status=status.HTTP_200_OK)
                else:
                    return Response({"error": "No quiz found for the specified ID"}, status=status.HTTP_404_NOT_FOUND)
            elif list_mode:
                if not self.has_super_admin_privileges(request):
                    return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
                quizzes = Quiz.objects.filter(
                    courses__id=course_id, 
                    active=True, 
                    deleted_at__isnull=True
                )
                serializer = QuizListPerCourseSerializer(quizzes, many=True)
                return Response(serializer.data, status=status.HTTP_200_OK)
            else:
                return Response({"error": "Specify 'content_id' or enable 'list' mode in query parameters."}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def post(self, request, course_id, *args, **kwargs):
        if not self.has_super_admin_privileges(request):
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)

        data = request.data
        if not data:
            return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)
        try:
            # Validate and save quiz
            requested_data = request.data.copy()
            requested_data['courses'] = [course_id]
            serializer = QuizSerializer(data=requested_data)
            if serializer.is_valid():
                quiz = serializer.save()
                # If original_course is null, only save quiz
                if course.original_course is None:
                    return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                else:
                    # If original_course is not null, also create a CourseStructure entry
                    try:
                        last_order_number = CourseStructure.objects.filter(course=course).latest('order_number').order_number
                    except CourseStructure.DoesNotExist:
                        last_order_number = 0
                    # Create new CourseStructure instance
                    course_structure_data = {
                        'course': course_id,
                        'order_number': last_order_number + 1,
                        'content_type': 'quiz',
                        'content_id': quiz.pk
                    }
                    course_structure_serializer = CourseStructureSerializer(data=course_structure_data)
                    if course_structure_serializer.is_valid():
                        course_structure_serializer.save()
                        return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                    else:
                        return Response({"error": course_structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class QuestionView(SuperAdminMixin, APIView):
    
    """
        post: to create question instances for course in url (for super admin only)
    """
    def get(self, request, quiz_id, format=None):
        try:
            if not self.has_super_admin_privileges(request) :
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
            questions = Question.objects.filter(
                quizzes__id=quiz_id, 
                active=True, 
                deleted_at__isnull=True
            )
            serializer = QuestionListPerQuizSerializer(questions, many=True)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
    def post(self, request, course_id, *args, **kwargs):
        if not self.has_super_admin_privileges(request) :
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        
        course = Course.objects.get(pk=course_id)
        if not course:
            return Response({"error": "Course not found"}, status=status.HTTP_404_NOT_FOUND)
        if course.active:
            return Response({"error": "Course is active, cannot proceed"}, status=status.HTTP_403_FORBIDDEN)

        data = request.data
        if not data:
            return Response({"error": "Request body is empty"}, status=status.HTTP_400_BAD_REQUEST)
        try:
            # Validate and save quiz
            requested_data = request.data.copy()
            requested_data['courses'] = [course_id]
            serializer = QuizSerializer(data=requested_data)
            if serializer.is_valid():
                quiz = serializer.save()
                # If original_course is null, only save quiz
                if course.original_course is None:
                    return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                else:
                    # If original_course is not null, also create a CourseStructure entry
                    try:
                        last_order_number = CourseStructure.objects.filter(course=course).latest('order_number').order_number
                    except CourseStructure.DoesNotExist:
                        last_order_number = 0
                    # Create new CourseStructure instance
                    course_structure_data = {
                        'course': course_id,
                        'order_number': last_order_number + 1,
                        'content_type': 'quiz',
                        'content_id': quiz.pk
                    }
                    course_structure_serializer = CourseStructureSerializer(data=course_structure_data)
                    if course_structure_serializer.is_valid():
                        course_structure_serializer.save()
                        return Response({"message": "Quiz created successfully"}, status=status.HTTP_201_CREATED)
                    else:
                        return Response({"error": course_structure_serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
            else:
                return Response({"error": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class ChoicesView(SuperAdminMixin, APIView):
    
    """
        post: to create choice instances for course in url (for super admin only)
    """
    def post(self, request, question_id, *args, **kwargs):
        if not self.has_super_admin_privileges(request) :
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
        question = Question.objects.get(pk=question_id)
        if not question:
            return  Response({"error": "Question not found"}, status=status.HTTP_404_NOT_FOUND)
        try:
            serializer = CreateChoiceSerializer(data=request.data, context={'question_id': question_id})
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except Exception as e:
                if isinstance(e, ValidationError):
                    return Response({"error": "Validation Error: " + str(e)}, status=status.HTTP_400_BAD_REQUEST)
                else:
                    return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)